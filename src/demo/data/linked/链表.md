链表是有序列表：
```$xslt
1> 链表是以节点的方式来存储,是链式存储
2> 每个节点包含data域，Next域指向下一个节点
3> 链表的各个节点不一定是连续存储
4> 链表分带头节点的链表和没有头节点的链表，根据实际需求来确定
```
案例：
- 1.求单链表中有效节点的个数
```$java
 public static int getLength(HearNode head) {
        if (head.next == null) {
            return 0;
        }
        int length = 0;
        //定义一个辅助变量
        HearNode cur = head.next;
        while (cur != null) {
            length++;
            cur = cur.next;
        }
        return length;
}
```

- 2.查找单链表中的倒数第K个节点
- 3.单链表的反转
- 4.从尾到头打印单链表（1.反向遍历，2stack）
- 5.合并两个有序的单链表，合并后仍然有序


#### 双向链表
- 分析双向链表的遍历，添加，修改，删除的操作 
```text
1.遍历：和单链表类似，只是可以向前，也可以向后查找

2.添加(默认添加到双向链表的最后)
1》 先找到双向链表的最后这个节点
2》 temp.next = newHearNode
3》 newHearNode pre = temp

3.修改的思路和单链表类似

4.删除：
1》 因为是双向链表，因此，我们可以实现自我删除某个节点
2》直接找到要删除的这个节点，比如temp
3》 temp.pre.next = temp.next
4》 temp.next.pre = temp.next

```
##### 双向链表应用实例
使用带head头的双向链表实现 - 水浒英雄排行榜

管理单向链表的缺点分析
1. 单向链表，查找的方向只能是一个方向，而双向链表可以向前或者向后查询

2.单向链表不能自我删除，要靠辅助节点，而双向链表，则可以自我删除，所以单链表删除节点时，
我们需要temp，而temp是待删除节点的前一个节点

#### 单向环形链表
1. 先创建第一个节点，让first 指向该节点，并形成环形

2.后面当我们每创建一个新的节点，就把该节点，加入到已有的环形链表中即可

- 遍历环形链表

1.先让一个辅助指针变量 jcurBoy，指向first

2.然后通过一个while循环遍历循环该环形链表即可，curBoy.next = first 结束

- 小孩出圈

根据用户的输入，生成一个小孩出圈的顺序
```text
m = 5 ,即有5个人
k = 1 从第一个人开始报数
m = 2 数两下

1.需求创建一个辅助指针[变量]


```

  





